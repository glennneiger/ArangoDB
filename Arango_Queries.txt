
///Insert
for loopcounter in 1..1

//let del1=(for doc1 in node1 remove doc1 in node1)
//let del2=(for doc2 in edge1 remove doc2 in edge1)
let in1=(FOR n IN 1..15  INSERT {"_key":CONCAT("", n), "field1":CONCAT('value-', n), "range": n } IN node1)
let in2=(FOR i IN 1..14  INSERT { "_from":CONCAT("node1","/", i),"_to":CONCAT("node1","/", i+1),"desc":CONCAT(i,"to", i+1)} in edge1)

return loopcounter


//FOR v, e, p IN 1..10 OUTBOUND 'cities/Pune' GRAPH 'city_grapth'   FILTER e.distance>=50   RETURN p
 
 
FOR v, e  IN OUTBOUND SHORTEST_PATH 'cities/Vadodara' TO 'cities/Rajkot' GRAPH 'city_grapth'
RETURN [CONCAT(e._from, " --> " , e._to,"   ",e.distance)]


LET p = ( // Run one shortest Path
  FOR v, e IN OUTBOUND SHORTEST_PATH 'cities/Vadodara' TO 'cities/Rajkot' GRAPH 'road_graph'
  // We return objects with vertex, edge and weight for each vertex on the path
  RETURN {vertex: v, edge: e, weight: e.distance}
)
FILTER LENGTH(p) > 0 // We only want shortest paths that actually exist
RETURN { // We rebuild the old format
  vertices: p[*].vertex.name,
  edges: p[*].edge.distance,
  distance: SUM(p[*].weight)
}


FOR u IN roads
  COLLECT AGGREGATE shortest = MIN(u.distance), longest = MAX(u.distance), total=sum(u.distance)
  RETURN {shortest, longest,total }


  FOR v, e, p IN 1..15 OUTBOUND "cities/Vadodara" roads
  FILTER v._id == "cities/Rajkot"
  RETURN CONCAT_SEPARATOR(" -> ", p.vertices[*]._key)  
  
  #Shortest distance
  FOR v, e, p IN 1..15 ANY "cities/Pune" roads
  FILTER v._id == "cities/Rajkot"
  let lst= ({path:CONCAT_SEPARATOR(" -> ", p.vertices[*]._key),distance:SUM(p.edges[*].distance),stops:count(p.edges[*]._id)})
  sort lst.distance 
  return lst